{"/home/travis/build/npmtest/node-npmtest-lab/test.js":"/* istanbul instrument in package npmtest_lab */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-lab/lib.npmtest_lab.js":"/* istanbul instrument in package npmtest_lab */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_lab = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_lab = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-lab/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-lab && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_lab */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_lab\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_lab.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_lab.rollup.js'] =\n            local.assetsDict['/assets.npmtest_lab.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_lab.__dirname + '/lib.npmtest_lab.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Coverage = require('./coverage');\nconst Leaks = require('./leaks');\nconst Runner = require('./runner');\nconst Utils = require('./utils');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Exports\n\nexports.report = Runner.report;\nexports.execute = Runner.execute;\nexports.coverage = Coverage;\nexports.leaks = Leaks;\nexports.assertions = null;                                              // Set by the -a command line option\n\n\n/*\n    experiment('Utilities', () => {\n\n        experiment('#isEven()', () => {\n\n            test('returns true on even values', (done) => {\n\n            });\n\n            test('returns false on odd values', (done) => {\n\n            });\n        });\n    });\n */\n\n\nexports.script = function (options) {\n\n    options = options || {};\n\n    global._labScriptRun = true;                                        // Compared by CLI to detect missing exports.lab\n\n    const script = {\n        _current: {\n            experiments: [],\n            tests: [],\n            options: {},\n            title: 'script'\n        },\n        _titles: [],\n        _path: [],\n        _count: 0,\n        _executed: false,\n        _onlyNodes: [],\n        _cli: options.cli,\n        setOnly: function (experiment, test, path) {\n\n            this._onlyNodes.push({ experiment, test, path });\n        }\n    };\n\n    script._root = script._current;\n\n    script.experiment = internals.experiment.bind(script);\n    script.experiment.skip = internals.skip(script, 'experiment');\n    script.experiment.only = internals.only(script, 'experiment');\n    script.describe = script.experiment;\n    script.suite = script.experiment;\n\n    script.test = internals.test.bind(script);\n    script.test.skip = internals.skip(script, 'test');\n    script.test.only = internals.only(script, 'test');\n    script.it = script.test;\n\n    script.before = internals.before.bind(script);\n    script.beforeEach = internals.beforeEach.bind(script);\n    script.after = internals.after.bind(script);\n    script.afterEach = internals.afterEach.bind(script);\n\n    if (options.schedule !== false) {                   // Defaults to true\n        setImmediate(() => {\n\n            if (!script._executed) {\n                Runner.report(script, options);         // Schedule automatic execution when used without the CLI\n            }\n        });\n    }\n\n    return script;\n};\n\n\ninternals.experiment = function (title /*, options, fn */) {\n\n    const options = arguments.length === 3 ? arguments[1] : {};\n    const fn = arguments.length === 3 ? arguments[2] : arguments[1];\n\n    const settings = Utils.mergeOptions(this._current.options, options, ['only']);\n\n    const child = {\n        title,\n        parent: this._current,\n        experiments: [],\n        tests: [],\n        options: settings\n    };\n\n    this._current.experiments.push(child);\n    this._current = child;\n\n    this._titles.push(title);\n    this._path = this._titles.concat();                      // Clone\n\n    if (settings.only) {\n        this.setOnly(child, null, this._path);\n    }\n\n    fn.call(null);\n\n    this._titles.pop();\n    this._path = this._titles.concat();                      // Clone\n\n    this._current = child.parent;\n};\n\n\ninternals.before = function (/* options, */ fn) {\n\n    const options = arguments.length === 2 ? arguments[0] : {};\n    fn = arguments.length === 2 ? arguments[1] : fn;\n\n    Hoek.assert(fn, `before in \"${this._current.title}\" requires a function argument`);\n\n    const before = {\n        title: 'Before ' + this._titles.join(' '),\n        fn,\n        options\n    };\n\n    this._current.befores = this._current.befores || [];\n    this._current.befores.push(before);\n};\n\n\ninternals.after = function (/* options, */ fn) {\n\n    const options = arguments.length === 2 ? arguments[0] : {};\n    fn = arguments.length === 2 ? arguments[1] : fn;\n\n    Hoek.assert(fn, `after in \"${this._current.title}\" requires a function argument`);\n\n    const after = {\n        title: 'After ' + this._titles.join(' '),\n        fn,\n        options\n    };\n\n    this._current.afters = this._current.afters || [];\n    this._current.afters.push(after);\n};\n\n\ninternals.beforeEach = function (/* options, */ fn) {\n\n    const options = arguments.length === 2 ? arguments[0] : {};\n    fn = arguments.length === 2 ? arguments[1] : fn;\n\n    Hoek.assert(fn, `beforeEach in \"${this._current.title}\" requires a function argument`);\n\n    const beforeEach = {\n        title: 'Before each ' + this._titles.join(' '),\n        fn,\n        options\n    };\n\n    this._current.beforeEaches = this._current.beforeEaches || [];\n    this._current.beforeEaches.push(beforeEach);\n};\n\n\ninternals.afterEach = function (/* options, */ fn) {\n\n    const options = arguments.length === 2 ? arguments[0] : {};\n    fn = arguments.length === 2 ? arguments[1] : fn;\n\n    Hoek.assert(fn, `afterEach in \"${this._current.title}\" requires a function argument`);\n\n    const afterEach = {\n        title: 'After each ' + this._titles.join(' '),\n        fn,\n        options\n    };\n\n    this._current.afterEaches = this._current.afterEaches || [];\n    this._current.afterEaches.push(afterEach);\n};\n\n\ninternals.test = function (title /*, options, fn */) {\n\n    const options = arguments.length === 3 ? arguments[1] : {};\n    const fn = arguments.length === 3 ? arguments[2] : arguments[1];\n\n    const settings = Utils.mergeOptions(this._current.options, options, ['only']);\n\n    const test = {\n        path: this._path,\n        title: this._titles.concat(title).join(' '),\n        relativeTitle: title,\n        fn,\n        options: settings\n    };\n\n    if (settings.only) {\n        this.setOnly(this._current, test, this._path);\n    }\n\n    this._current.tests.push(test);\n};\n\n\ninternals.skip = function (script, type) {\n\n    return function (title /*, options, fn */) {\n\n        const options = arguments.length === 3 ? arguments[1] : {};\n        const fn = arguments.length === 3 ? arguments[2] : arguments[1];\n\n        script[type](title, Utils.mergeOptions({ skip: true }, options), fn);\n    };\n};\n\n\ninternals.only = function (script, type) {\n\n    return function (title /*, options, fn */) {\n\n        const options = arguments.length === 3 ? arguments[1] : {};\n        const fn = arguments.length === 3 ? arguments[2] : arguments[1];\n\n        script[type](title, Utils.mergeOptions({ only: true }, options), fn);\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/coverage.js":"'use strict';\n\n// Adapted from:\n// Blanket https://github.com/alex-seville/blanket, copyright (c) 2013 Alex Seville, MIT licensed\n// Falafel https://github.com/substack/node-falafel, copyright (c) James Halliday, MIT licensed\n\n\n// Load modules\n\nconst Fs = require('fs');\nconst Path = require('path');\nconst Espree = require('espree');\nconst SourceMapConsumer = require('source-map').SourceMapConsumer;\nconst SourceMapSupport = require('source-map-support');\nconst Transform = require('./transform');\n\n\n// Declare internals\n\nconst internals = {\n    patterns: [],\n    sources: {}\n};\n\n\ninternals.prime = function (extension) {\n\n    require.extensions[extension] = function (localModule, filename) {\n\n        for (let i = 0; i < internals.patterns.length; ++i) {\n            if (internals.patterns[i].test(filename.replace(/\\\\/g, '/'))) {\n                return localModule._compile(internals.instrument(filename), filename);\n            }\n        }\n\n        const src = Fs.readFileSync(filename, 'utf8');\n        return localModule._compile(Transform.transform(filename, src), filename);\n    };\n};\n\n\nexports.instrument = function (options) {\n\n    internals.patterns.unshift(internals.pattern(options));\n\n    Transform.install(options, internals.prime);\n};\n\n\ninternals.pattern = function (options) {\n\n    const base = internals.escape(options.coveragePath || '');\n    let excludes = options.coverageExclude ? [].concat(options.coverageExclude).map(internals.escape) : '';\n    excludes = excludes ? excludes.map((exclude) => `${exclude}\\\\/`).join('|') : excludes;\n    const regex = '^' + base + (excludes ? (base[base.length - 1] === '/' ? '' : '\\\\/') + '(?!' + excludes + ')' : '');\n    return new RegExp(regex);\n};\n\n\ninternals.escape = function (string) {\n\n    return string.replace(/\\\\/g, '/').replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n};\n\n\ninternals.instrument = function (filename) {\n\n    filename = filename.replace(/\\\\/g, '/');\n\n    const file = Fs.readFileSync(filename, 'utf8');\n    let content = file.replace(/^\\#\\!.*/, '');\n    content = Transform.transform(filename, content);\n\n    const tracking = [];\n    const statements = [];\n    const chunks = content.split('');\n    let ids = 0;\n    const bypass = {};\n    const nodesByLine = {};\n\n    const addStatement = function (line, node, bool) {\n\n        const id = ++ids;\n        statements.push({\n            id,\n            loc: node.loc,\n            line,\n            bool: bool && node.type !== 'ConditionalExpression' && node.type !== 'LogicalExpression'\n        });\n        return id;\n    };\n\n    const addToLines = function (node, line) {\n\n        if (!(line in nodesByLine)) {\n            nodesByLine[line] = [];\n        }\n        nodesByLine[line].push(node.type);\n    };\n\n    const annotate = function (node, parent) {\n\n        const line = node.loc.start.line;\n        // Decorate node\n\n        node.parent = parent;\n\n        node.source = function () {\n\n            return chunks.slice(node.range[0], node.range[1]).join('');\n        };\n\n        node.set = function (s) {\n\n            chunks[node.range[0]] = s;\n            for (let i = node.range[0] + 1; i < node.range[1]; ++i) {\n                chunks[i] = '';\n            }\n        };\n\n        // Reference node types per line, to detect commented lines\n        addToLines(node, line);\n        const end = node.loc.end.line;\n        if (end !== line) {\n            addToLines(node, end);\n        }\n\n        // Coverage status\n\n        const bypassTests = [];\n        for (let i = node.range[0]; i <= node.range[1]; ++i) {\n            bypassTests.push(bypass[i]);\n        }\n        if (bypassTests.every((test) => test)) {\n            return;\n        }\n\n        // Recursively annotate the tree from the inner-most out\n\n        Object.keys(node).forEach((name) => {\n\n            if (name === 'parent') {\n                return;\n            }\n\n            const children = [].concat(node[name]);\n            children.forEach((child) => {\n\n                if (child && typeof child.type === 'string') {              // Identify node types\n                    annotate(child, node);\n                }\n            });\n        });\n\n        // Annotate source code\n\n        const decoratedTypes = [\n            'IfStatement',\n            'WhileStatement',\n            'DoWhileStatement',\n            'ForStatement',\n            'ForInStatement',\n            'WithStatement'\n        ];\n\n        let consequent;\n\n        if (decoratedTypes.indexOf(node.type) !== -1) {\n            if (node.alternate &&\n                node.alternate.type !== 'BlockStatement') {\n\n                node.alternate.set(`{${node.alternate.source()}}`);\n            }\n\n            consequent = node.consequent || node.body;\n            if (consequent.type !== 'BlockStatement') {\n                consequent.set(`{${consequent.source()}}`);\n            }\n        }\n\n        if (node.type === 'ExpressionStatement' && node.expression.value === 'use strict') {\n            return;\n        }\n\n        const trackedTypes = [\n            'ExpressionStatement',\n            'BreakStatement',\n            'ContinueStatement',\n            'VariableDeclaration',\n            'ReturnStatement',\n            'ThrowStatement',\n            'TryStatement',\n            'IfStatement',\n            'WhileStatement',\n            'DoWhileStatement',\n            'ForStatement',\n            'ForInStatement',\n            'SwitchStatement',\n            'WithStatement',\n            'LabeledStatement'\n        ];\n\n\n        if (node.parent && node.parent.type === 'BlockStatement' &&\n            node.parent.parent.type.includes('FunctionExpression') &&\n            node.parent.body[0] === node) {\n\n            const id = addStatement(line, node, false);\n\n            node.set(`global.__$$labCov._statement('${filename}', ${id}, ${line}, true); ${node.source()};`);\n        }\n        else if (trackedTypes.indexOf(node.type) !== -1 &&\n            (node.type !== 'VariableDeclaration' || (node.parent.type !== 'ForStatement' && node.parent.type !== 'ForInStatement'  && node.parent.type !== 'ForOfStatement')) &&\n            node.parent.type !== 'LabeledStatement') {\n\n            tracking.push(line);\n            node.set(`global.__$$labCov._line('${filename}',${line});${node.source()}`);\n        }\n        else if (node.type === 'ConditionalExpression') {\n            consequent = addStatement(line, node.consequent, false);\n            const alternate = addStatement(line, node.alternate, false);\n\n            node.set(`(${node.test.source()}? global.__$$labCov._statement('${filename}',${consequent},${line},(${node.consequent.source()})) : global.__$$labCov._statement('${filename}',${alternate},${line},(${node.alternate.source()})))`);\n        }\n        else if (node.type === 'LogicalExpression') {\n            const left = addStatement(line, node.left, true);\n            const right = addStatement(line, node.right, node.parent.type === 'LogicalExpression');\n\n            node.set(`(global.__$$labCov._statement(\\'${filename }\\',${left},${line},${node.left.source()})${node.operator}global.__$$labCov._statement(\\'${filename}\\',${right},${line},${node.right.source()}))`);\n        }\n        else if (node.parent && node.parent.type === 'ArrowFunctionExpression' &&\n            node.type.includes('Expression')) {\n\n            const id = addStatement(line, node, false);\n\n            node.set(`global.__$$labCov._statement('${filename}', ${id}, ${line}, ${node.source()})`);\n        }\n        else if (node.parent &&\n            node.parent.test === node &&\n            node.parent.type !== 'SwitchCase') {\n\n            const test = addStatement(line, node, true);\n\n            node.set(`global.__$$labCov._statement(\\'${filename}\\',${test},${line},${node.source()})`);\n        }\n    };\n\n    // Parse tree\n\n    const tree = Espree.parse(content, {\n        loc: true,\n        comment: true,\n        range: true,\n        ecmaVersion: 8\n    });\n\n    // Process comments\n\n    let skipStart = 0;\n    let segmentSkip = false;\n    tree.comments.forEach((comment) => {\n\n        const directive = comment.value.match(/^\\s*\\$lab\\:coverage\\:(off|on)\\$\\s*$/);\n        if (directive) {\n            const skip = directive[1] !== 'on';\n            if (skip !== segmentSkip) {\n                segmentSkip = skip;\n                if (skip) {\n                    skipStart = comment.range[1];\n                }\n                else {\n                    for (let i = skipStart; i < comment.range[0]; ++i) {\n                        bypass[i] = true;\n                    }\n                }\n            }\n        }\n    });\n\n    // Begin code annotation\n\n    annotate(tree);\n\n    // Store original source\n\n    const transformedFile = content.replace(/\\/\\/\\#(.*)$/, '');\n    internals.sources[filename] = transformedFile.replace(/(\\r\\n|\\n|\\r)/gm, '\\n').split('\\n');\n\n    // Setup global report container\n                                                        // $lab:coverage:off$\n    if (typeof global.__$$labCov === 'undefined') {\n        global.__$$labCov = {\n            files: {},\n\n            _line: function (name, line) {\n\n                global.__$$labCov.files[name].lines[line]++;\n            },\n\n            _statement: function (name, id, line, source) {\n\n                const statement = global.__$$labCov.files[name].statements[line][id];\n                if (!statement.bool) {\n                    statement.hit[!source] = true;\n                }\n\n                statement.hit[!!source] = true;\n                return source;\n            }\n        };\n    }                                                   // $lab:coverage:on$\n\n    if (typeof global.__$$labCov.files[filename] === 'undefined') {\n        global.__$$labCov.files[filename] = {\n            statements: {},\n            lines: {},\n            commentedLines: {}\n        };\n\n        const record = global.__$$labCov.files[filename];\n        tracking.forEach((item) => {\n\n            record.lines[item] = 0;\n        });\n\n        statements.forEach((item) => {\n\n            record.statements[item.line] = record.statements[item.line] || {};\n            record.statements[item.line][item.id] = { hit: {}, bool: item.bool, loc: item.loc };\n        });\n\n        const blank = /^\\s*$/;\n        // Compute SLOC by counting all non-blank lines, and subtract comments\n        // Don't bother with actual coverage (dealing with hits, misses and bypass is tricky) and rely only on AST\n        // Only comments that don't share the same line with something else must be subtracted\n        record.sloc = internals.sources[filename].filter((line) => !blank.test(line)).length -\n            tree.comments.map((node) => {\n\n                const start = node.loc.start.line;\n                const end = node.loc.end.line;\n                let commented = 0;\n                // But don't count commented white lines, cause there are already subtracted\n                for (let i = start; i <= end; ++i) {\n                    // Don't consider line commented if it contains something which isn't another comment\n                    if ((!nodesByLine[i] || !nodesByLine[i].find((type) => type !== 'Line' && type !== 'Block')) && !record.commentedLines[i]) {\n                        record.commentedLines[i] = true;\n\n                        // Acorn removes comment delimiters, so start and end lines must never be considered blank if they content is\n                        if (i === start || i === end || !blank.test(internals.sources[filename][i - 1])) {\n                            commented++;\n                        }\n                    }\n                }\n                return commented;\n            }).reduce((a, b) => a + b, 0);\n    }\n\n    return chunks.join('');\n};\n\n\nexports.analyze = function (options) {\n\n    // Process coverage  (global.__$$labCov needed when labCov isn't defined)\n\n    /* $lab:coverage:off$ */ const report = global.__$$labCov || { files: {} }; /* $lab:coverage:on$ */\n    const pattern = internals.pattern(options);\n\n    const cov = {\n        sloc: 0,\n        hits: 0,\n        misses: 0,\n        percent: 0,\n        files: []\n    };\n\n    // Filter files\n\n    const files = Object.keys(report.files);\n    for (let i = 0; i < files.length; ++i) {\n        const filename = files[i];\n        if (pattern.test(filename)) {\n            report.files[filename].source = internals.sources[filename] || [];\n            const data = internals.file(filename, report.files[filename], options);\n\n            cov.files.push(data);\n            cov.hits += data.hits;\n            cov.misses += data.misses;\n            cov.sloc += data.sloc;\n        }\n    }\n\n    // Sort files based on directory structure\n\n    cov.files.sort((a, b) => {\n\n        const segmentsA = a.filename.split('/');\n        const segmentsB = b.filename.split('/');\n\n        const al = segmentsA.length;\n        const bl = segmentsB.length;\n\n        for (let i = 0; i < al && i < bl; ++i) {\n\n            if (segmentsA[i] === segmentsB[i]) {\n                continue;\n            }\n\n            const lastA = i + 1 === al;\n            const lastB = i + 1 === bl;\n\n            if (lastA !== lastB) {\n                return lastA ? -1 : 1;\n            }\n\n            return segmentsA[i] < segmentsB[i] ? -1 : 1;\n        }\n\n        return segmentsA.length < segmentsB.length ? -1 : 1;\n    });\n\n    // Calculate coverage percentage\n\n    if (cov.sloc > 0) {\n        cov.percent = (cov.hits / cov.sloc) * 100;\n    }\n\n    return cov;\n};\n\ninternals.addSourceMapsInformation = function (smc, ret, num) {\n\n    const source = ret.source[num];\n    const position = {\n        source: ret.filename,\n        line: num,\n        // when using 0 column, it sometimes miss the original line\n        column: source.source.length\n    };\n    let originalPosition = smc.originalPositionFor(position);\n\n    // Ensure folder separator to be url-friendly\n    source.originalFilename = originalPosition.source && originalPosition.source.replace(/\\\\/g, '/');\n    source.originalLine = originalPosition.line;\n\n    if (!ret.sourcemaps) {\n        ret.sourcemaps = true;\n    }\n\n    if (source.chunks) {\n        source.chunks.forEach((chunk) => {\n            // Also add source map information on chunks\n            originalPosition = smc.originalPositionFor({ line: num, column: chunk.column });\n            chunk.originalFilename = originalPosition.source;\n            chunk.originalLine = originalPosition.line;\n            chunk.originalColumn = originalPosition.column;\n        });\n    }\n};\n\n\ninternals.file = function (filename, data, options) {\n\n    const ret = {\n        // Ensure folder separator to be url-friendly\n        filename: filename.replace(Path.join(process.cwd(), '/').replace(/\\\\/g, '/'), ''),\n        percent: 0,\n        hits: 0,\n        misses: 0,\n        sloc: data.sloc,\n        source: {}\n    };\n\n    // Use sourcemap consumer rather than SourceMapSupport.mapSourcePosition itself which perform path transformations\n    const sourcemap = options.sourcemaps ? SourceMapSupport.retrieveSourceMap(ret.filename) : null;\n    const smc = sourcemap ? new SourceMapConsumer(sourcemap.map) : null;\n\n    // Process each line of code\n    data.source.forEach((line, num) => {\n\n        num++;\n\n        let isMiss = false;\n        ret.source[num] = {\n            source: line\n        };\n\n        if (data.lines[num] === 0) {\n            isMiss = true;\n            ret.misses++;\n        }\n        else if (line) {\n            if (data.statements[num]) {\n                const mask = new Array(line.length);\n                Object.keys(data.statements[num]).forEach((id) => {\n\n                    const statement = data.statements[num][id];\n                    if (statement.hit.true &&\n                        statement.hit.false) {\n\n                        return;\n                    }\n\n                    if (statement.loc.start.line !== num) {\n                        data.statements[statement.loc.start.line] = data.statements[statement.loc.start.line] || {};\n                        data.statements[statement.loc.start.line][id] = statement;\n                        return;\n                    }\n\n                    if (statement.loc.end.line !== num) {\n                        data.statements[statement.loc.end.line] = data.statements[statement.loc.end.line] || {};\n                        data.statements[statement.loc.end.line][id] = {\n                            hit: statement.hit,\n                            loc: {\n                                start: {\n                                    line: statement.loc.end.line,\n                                    column: 0\n                                },\n                                end: {\n                                    line: statement.loc.end.line,\n                                    column: statement.loc.end.column\n                                }\n                            }\n                        };\n\n                        statement.loc.end.column = line.length;\n                    }\n\n                    isMiss = true;\n                    const issue = statement.hit.true ? 'true' : (statement.hit.false ? 'false' : 'never');\n                    for (let i = statement.loc.start.column; i < statement.loc.end.column; ++i) {\n                        mask[i] = issue;\n                    }\n                });\n\n                const chunks = [];\n\n                let from = 0;\n                for (let i = 1; i < mask.length; ++i) {\n                    if (mask[i] !== mask[i - 1]) {\n                        chunks.push({ source: line.slice(from, i), miss: mask[i - 1], column: from });\n                        from = i;\n                    }\n                }\n\n                chunks.push({ source: line.slice(from), miss: mask[from], column: from });\n\n                if (isMiss) {\n                    ret.source[num].chunks = chunks;\n                    ret.misses++;\n                }\n                else {\n                    ret.hits++;\n                }\n            }\n            else if (!data.commentedLines[num] && line.trim()) {\n                // Only increment hits if the current line isn't blank and commented\n                ret.hits++;\n            }\n        }\n\n        if (smc) {\n            internals.addSourceMapsInformation(smc, ret, num);\n        }\n\n        ret.source[num].hits = data.lines[num];\n        ret.source[num].miss = isMiss;\n    });\n\n    ret.percent = ret.hits / ret.sloc * 100;\n    return ret;\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/transform.js":"'use strict';\n\n// Load modules\n\nconst Fs = require('fs');\n\n// Declare internals\n\nconst internals = {\n    fileCache: {},\n    transforms: [{ ext: '.js', transform: null }]\n};\n\n\ninternals.prime = function (extension) {\n\n    require.extensions[extension] = function (localModule, filename) {\n\n        const src = Fs.readFileSync(filename, 'utf8');\n        return localModule._compile(exports.transform(filename, src), filename);\n    };\n};\n\n\nexports.install = function (settings, primeFn) {\n\n    if (Array.isArray(settings.transform)) {\n        settings.transform.forEach((element) => {\n\n            if (element.ext === '.js') {\n                internals.transforms[0].transform = element.transform;\n            }\n            else {\n                internals.transforms.push(element);\n            }\n        });\n    }\n\n    if (typeof primeFn !== 'function') {\n        primeFn = internals.prime;\n    }\n\n    internals.transforms.forEach((transform) => {\n\n        primeFn(transform.ext);\n    });\n};\n\n\nexports.transform = function (filename, content) {\n\n    let ext = '';\n    let transform = null;\n\n    internals.transforms.forEach((element) => {\n\n        ext = element.ext;\n        if (filename.indexOf(ext, filename.length - ext.length) !== -1) {\n            transform = element.transform;\n        }\n    });\n\n    const relativeFilename = filename.substr(process.cwd().length + 1);\n    internals.fileCache[relativeFilename] = (typeof transform === 'function') ? transform(content, relativeFilename) : content;\n    return internals.fileCache[relativeFilename];\n};\n\n\nexports.retrieveFile = function (path) {\n\n    const cwd = process.cwd();\n    const cacheKey = path.indexOf(cwd) === 0 ? path.substr(cwd.length + 1) : path;\n    if (internals.fileCache[cacheKey]) {\n        return internals.fileCache[cacheKey];\n    }\n\n    let contents = null;\n    try {\n        contents = Fs.readFileSync(path, 'utf8');\n    }\n    catch (e) {\n        contents = null;\n    }\n\n    internals.fileCache[path] = contents;\n\n    return contents;\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/leaks.js":"'use strict';\n\n// Load modules\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.detect = function (customGlobals) {\n\n    const whitelist = {\n        _labScriptRun: true,                // Lab global to detect script executions\n\n        // Enumerable globals\n        setTimeout: true,\n        setInterval: true,\n        setImmediate: true,\n        clearTimeout: true,\n        clearInterval: true,\n        clearImmediate: true,\n        console: true,\n        Buffer: true,\n        process: true,\n        global: true,\n        GLOBAL: true,\n        root: true,\n        constructor: true,\n        ArrayBuffer: true,\n        Int8Array: true,\n        Uint8Array: true,\n        Uint8ClampedArray: true,\n        Int16Array: true,\n        Uint16Array: true,\n        Int32Array: true,\n        Uint32Array: true,\n        Float32Array: true,\n        Float64Array: true,\n        DataView: true,\n        __$$labCov: true,\n        gc: true,\n\n        // Non-Enumerable globals\n        Array: true,\n        isNaN: true,\n        ReferenceError: true,\n        Number: true,\n        RangeError: true,\n        EvalError: true,\n        Function: true,\n        isFinite: true,\n        Object: true,\n        undefined: true,\n        Date: true,\n        SyntaxError: true,\n        String: true,\n        eval: true,\n        parseFloat: true,\n        unescape: true,\n        Error: true,\n        encodeURI: true,\n        NaN: true,\n        RegExp: true,\n        encodeURIComponent: true,\n        Math: true,\n        decodeURI: true,\n        parseInt: true,\n        Infinity: true,\n        escape: true,\n        decodeURIComponent: true,\n        JSON: true,\n        TypeError: true,\n        URIError: true,\n        Boolean: true,\n        Intl: true,\n        Map: true,\n        Promise: true,\n        Set: true,\n        Symbol: true,\n        WeakMap: true,\n        WeakSet: true\n    };\n\n    if (customGlobals) {\n        for (let i = 0; i < customGlobals.length; ++i) {\n            whitelist[customGlobals[i]] = true;\n        }\n    }\n\n    if (global.Proxy) {\n        whitelist.Proxy = true;\n    }\n\n    if (global.Reflect) {\n        whitelist.Reflect = true;\n    }\n\n    if (global.DTRACE_HTTP_SERVER_RESPONSE) {\n        whitelist.DTRACE_HTTP_SERVER_RESPONSE = true;\n        whitelist.DTRACE_HTTP_SERVER_REQUEST = true;\n        whitelist.DTRACE_HTTP_CLIENT_RESPONSE = true;\n        whitelist.DTRACE_HTTP_CLIENT_REQUEST = true;\n        whitelist.DTRACE_NET_STREAM_END = true;\n        whitelist.DTRACE_NET_SERVER_CONNECTION = true;\n        whitelist.DTRACE_NET_SOCKET_READ = true;\n        whitelist.DTRACE_NET_SOCKET_WRITE = true;\n    }\n\n    if (global.COUNTER_NET_SERVER_CONNECTION) {\n        whitelist.COUNTER_NET_SERVER_CONNECTION = true;\n        whitelist.COUNTER_NET_SERVER_CONNECTION_CLOSE = true;\n        whitelist.COUNTER_HTTP_SERVER_REQUEST = true;\n        whitelist.COUNTER_HTTP_SERVER_RESPONSE = true;\n        whitelist.COUNTER_HTTP_CLIENT_REQUEST = true;\n        whitelist.COUNTER_HTTP_CLIENT_RESPONSE = true;\n    }\n\n    const leaks = [];\n    const globals = Object.getOwnPropertyNames(global);\n    for (let i = 0; i < globals.length; ++i) {\n        if (!whitelist[globals[i]] &&\n            global[globals[i]] !== global) {\n\n            leaks.push(globals[i]);\n        }\n    }\n\n    return leaks;\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/runner.js":"'use strict';\n\n// Load modules\n\n// 'cluster' loaded below in internals.loadLazyObjects()\nconst Domain = require('domain');\nconst Items = require('items');\nconst Hoek = require('hoek');\nconst Seedrandom = require('seedrandom');\nconst Reporters = require('./reporters');\nconst Coverage = require('./coverage');\nconst Linters = require('./lint');\nconst Leaks = require('./leaks');\nconst Utils = require('./utils');\n\n// prevent libraries like Sinon from clobbering global time functions\n\nconst Date = global.Date;\nconst setTimeout = global.setTimeout;\nconst clearTimeout = global.clearTimeout;\nconst setImmediate = global.setImmediate;\n\n\n// Declare internals\n\nconst internals = {};\n\n\nError.stackTraceLimit = Infinity;                   // Set Error stack size\n\n\ninternals.defaults = {\n\n    // assert: { incomplete(), count() },\n    bail: false,\n    coverage: false,\n\n    // coveragePath: process.cwd(),\n    // coverageExclude: ['node_modules', 'test'],\n    colors: null,                                   // true, false, null (based on tty)\n    dry: false,\n    debug: false,\n    environment: 'test',\n\n    // flat: false,\n    grep: null,\n    ids: [],\n    globals: null,\n    leaks: true,\n    timeout: 2000,\n    output: process.stdout,                         // Stream.Writable or string (filename)\n    parallel: false,\n    progress: 1,\n    rejections: false,\n    reporter: 'console',\n    shuffle: false,\n    seed: Math.floor(Math.random() * 1000),\n\n    // schedule: true,\n    threshold: 0,\n\n    lint: false,\n    'lint-fix': false,\n    'lint-errors-threshold': 0,\n    'lint-warnings-threshold': 0\n};\n\n\nexports.report = function (scripts, options, callback) {\n\n    const settings = Utils.mergeOptions(internals.defaults, options);\n    settings.environment = settings.environment.trim();\n    const reporter = Reporters.generate(settings);\n\n    const executeScripts = function (next) {\n\n        exports.execute(scripts, settings, reporter, (err, result) => {\n            // Can only be (and is) covererd via CLI tests\n            /* $lab:coverage:off$ */\n            if (err) {\n                const outputStream = [].concat(options.output).find((output) => !!output.write);\n                if (outputStream) {\n                    outputStream.write(err.toString() + '\\n');\n                }\n                else {\n                    console.error(err.toString());\n                }\n                return process.exit(1);\n            }\n            /* $lab:coverage:on$ */\n\n            if (settings.leaks) {\n                result.leaks = Leaks.detect(settings.globals);\n            }\n\n            if (settings.coverage) {\n                result.coverage = Coverage.analyze(settings);\n            }\n\n            if (settings.shuffle) {\n                result.seed = settings.seed;\n                result.shuffle = true;\n            }\n\n            return next(null, result);\n        });\n    };\n\n    const executeLint = function (next) {\n\n        if (!settings.lint) {\n            return next();\n        }\n\n        Linters.lint(settings, next);\n    };\n\n    Items.parallel.execute({ notebook: executeScripts, lint: executeLint }, (ignoreErr, results) => {\n\n        const notebook = results.notebook;\n        notebook.lint = results.lint;\n\n        if (settings.assert) {\n            notebook.assertions = settings.assert.count && settings.assert.count();\n            const incompletes = settings.assert.incomplete && settings.assert.incomplete();\n            if (incompletes) {\n                for (let i = 0; i < incompletes.length; ++i) {\n                    const error = new Error('Incomplete assertion at ' + incompletes[i]);\n                    error.stack = undefined;\n                    notebook.errors.push(error);\n                }\n            }\n        }\n\n        return reporter.finalize(notebook, callback);\n    });\n};\n\n\nexports.execute = function (scripts, options, reporter, callback) {\n\n    const settings = Utils.mergeOptions(internals.defaults, options);\n\n    scripts = [].concat(scripts);\n\n    if (settings.shuffle) {\n        internals.shuffle(scripts, settings.seed);\n    }\n\n    const experiments = scripts.map((script) => {\n\n        script._executed = true;\n        return script._root;\n    });\n\n    const onlyNodes = Hoek.flatten(scripts.map((script) => script._onlyNodes));\n    if (onlyNodes.length > 1) {\n        const paths = onlyNodes.map((onlyNode) => {\n\n            if (onlyNode.test) {\n                return `Test: ${onlyNode.test.title}`;\n            }\n            return `Experiment: ${onlyNode.path}`;\n        });\n        return callback(new Error('Multiple tests are marked as \"only\":\\n\\t' + paths.join('\\n\\t')));\n    }\n\n    const onlyNode = onlyNodes[0];\n    if (onlyNode) {\n        internals.skipAllButOnly(scripts, onlyNode);\n    }\n\n    reporter = reporter || { test: function () { }, start: function () { } };\n\n    if (settings.environment) {\n        process.env.NODE_ENV = settings.environment;\n    }\n\n    const filters = {\n        ids: settings.ids,\n        grep: settings.grep ? new RegExp(settings.grep) : null\n    };\n\n    const count = internals.count(experiments, { filters });        // Sets test.id\n    reporter.start({ count });\n\n    const startTime = Date.now();\n    const state = {\n        report: {\n            tests: [],\n            failures: 0,\n            errors: []\n        },\n        reporter,\n        filters,\n        options: settings,\n        only: onlyNode\n    };\n\n    // Instantiate common lazily loaded items that can leak domains.\n    internals.loadLazyObjects();\n\n    internals.executeExperiments(experiments, state, settings.dry, () => {\n\n        const notebook = {\n            ms: Date.now() - startTime,\n            tests: state.report.tests,\n            failures: state.report.failures,\n            errors: state.report.errors\n        };\n\n        return callback(null, notebook);\n    });\n};\n\n\ninternals.loadLazyObjects = () => {\n    // Node core lazily loads many things. Once lab starts creating domains,\n    // any lazily created event emitters will hold a reference to those domains\n    // indefinitely.\n    process.stdout;\n    process.stderr;\n    require('cluster'); // Used in both TCP and UDP sockets.\n};\n\n\ninternals.skipAllButOnly = (scripts, onlyNode) => {\n\n    let currentExperiment = onlyNode.experiment;\n    if (onlyNode.test) {\n        currentExperiment.tests\n            .filter(internals.not(onlyNode.test))\n            .forEach(internals.enableSkip);\n        currentExperiment.experiments\n            .forEach(internals.enableSkip);\n    }\n\n    while (currentExperiment.parent) {\n        currentExperiment.parent.tests\n            .forEach(internals.enableSkip);\n        currentExperiment.parent.experiments\n            .filter(internals.not(currentExperiment))\n            .forEach(internals.enableSkip);\n        currentExperiment = currentExperiment.parent;\n    }\n\n    scripts.forEach((script) => {\n\n        if (script._onlyNodes.indexOf(onlyNode) === -1) {\n            internals.enableSkip(script._root);\n        }\n    });\n};\n\ninternals.not = (excludedElement) => {\n\n    return (element) => element !== excludedElement;\n};\n\n\ninternals.enableSkip = (element) => {\n\n    element.options.skip = true;\n};\n\ninternals.shuffle = function (scripts, seed) {\n\n    const random = Seedrandom(seed);\n\n    const last = scripts.length - 1;\n    for (let i = 0; i < scripts.length; ++i) {\n        const rand = i + Math.floor(random() * (last - i + 1));\n        const temp = scripts[i];\n        scripts[i] = scripts[rand];\n        scripts[rand] = temp;\n    }\n};\n\n\ninternals.executeExperiments = function (experiments, state, skip, callback) {\n\n    Items.serial(experiments, (experiment, nextExperiment) => {\n\n        // Create a new domains context for this level of experiments, keep the old ones to restore them when finishing\n        const previousDomains = state.domains;\n        state.domains = [];\n\n        const skipExperiment = skip || experiment.options.skip || !internals.experimentHasTests(experiment, state) || (state.options.bail && state.report.failures);\n        const steps = [\n            function (next) {\n\n                // Before\n\n                if (skipExperiment) {\n                    return next();\n                }\n\n                internals.executeDeps(experiment.befores, state, (err) => {\n\n                    if (err) {\n                        internals.fail([experiment], state, skip, '\\'before\\' action failed');\n                    }\n\n                    return next(err);\n                });\n            },\n            function (next) {\n\n                // Tests\n\n                internals.executeTests(experiment, state, skipExperiment, next);\n            },\n            function (next) {\n\n                // Sub-experiments\n\n                internals.executeExperiments(experiment.experiments, state, skipExperiment, next);\n            },\n            function (next) {\n\n                // After\n\n                if (skipExperiment) {\n                    return next();\n                }\n\n                internals.executeDeps(experiment.afters, state, next);\n            }\n        ];\n\n        Items.serial(steps, (item, next) => {\n\n            item(next);\n        },\n        (err, results) => {\n\n            // Restore the domains we had before\n            state.domains = previousDomains;\n\n            if (err) {\n                state.report.errors.push(err);\n            }\n\n            nextExperiment();\n        });\n    },\n    (err) => {\n\n        callback(err);\n    });\n};\n\n\ninternals.executeDeps = function (deps, state, callback) {\n\n    if (!deps) {\n        return callback();\n    }\n\n    Items.serial(deps, (dep, next) => {\n\n        dep.options.timeout = Hoek.isInteger(dep.options.timeout) ? dep.options.timeout : state.options['context-timeout'];\n        internals.protect(dep, state, next);\n    }, callback);\n};\n\n\ninternals.executeTests = function (experiment, state, skip, callback) {\n\n    if (!experiment.tests.length) {\n        return callback();\n    }\n\n    // Collect beforeEach and afterEach from parents\n\n    const befores = skip ? [] : internals.collectDeps(experiment, 'beforeEaches');\n    const afters = skip ? [] : internals.collectDeps(experiment, 'afterEaches');\n\n    // Separate serial and parallel execution tests\n\n    const serial = [];\n    const parallel = [];\n\n    experiment.tests.forEach((test) => {\n\n        if (test.options.parallel ||\n            (test.options.parallel === undefined && state.options.parallel)) {\n\n            parallel.push(test);\n        }\n        else {\n            serial.push(test);\n        }\n    });\n\n    // Execute tests\n\n    const execute = function (test, nextTest) {\n\n        // TODO: I would remove this and use the skip mechanism for it\n        if ((state.filters.ids.length && state.filters.ids.indexOf(test.id) === -1) ||\n            (state.filters.grep && !state.filters.grep.test(test.title))) {\n\n            return nextTest();\n        }\n\n        const skipTest = skip || test.options.skip || (state.options.bail && state.report.failures);\n\n        const steps = [\n            function (next) {\n\n                if (skipTest) {\n                    return next();\n                }\n\n                // Before each\n\n                internals.executeDeps(befores, state, (err) => {\n\n                    if (err) {\n                        internals.failTest(test, state, skip, '\\'before each\\' action failed');\n                    }\n\n                    return next(err);\n                });\n            },\n            function (next) {\n\n                // Unit\n\n                if (!test.fn ||\n                    skipTest) {\n\n                    test[test.fn ? 'skipped' : 'todo'] = true;\n                    test.duration = 0;\n                    state.report.tests.push(test);\n                    state.reporter.test(test);\n                    return setImmediate(next);\n                }\n\n                const start = Date.now();\n                internals.protect(test, state, (err) => {\n\n                    if (err) {\n                        state.report.failures++;\n                        test.err = err;\n                        test.timeout = err.timeout;\n                    }\n\n                    test.duration = Date.now() - start;\n\n                    state.report.tests.push(test);\n                    state.reporter.test(test);\n\n                    return next();\n                });\n            },\n            function (next) {\n\n                if (skipTest) {\n                    return next();\n                }\n\n                // After each\n\n                return internals.executeDeps(afters, state, next);\n            }\n        ];\n\n        Items.serial(steps, (item, next) => {\n\n            item(next);\n        },\n        (err, results) => {\n\n            if (err) {\n                state.report.errors.push(err);\n            }\n\n            return nextTest();\n        });\n    };\n\n    Items.serial(serial, execute, (err) => {\n\n        Items.parallel(parallel, execute, () => {\n\n            return callback(err);\n        });\n    });\n};\n\n\ninternals.experimentHasTests = function (experiment, state) {\n\n    if (experiment.experiments.length) {\n        const experimentsHasTests = experiment.experiments.some((childExperiment) => {\n\n            return internals.experimentHasTests(childExperiment, state);\n        });\n\n        if (experimentsHasTests) {\n            return true;\n        }\n    }\n\n    const hasTests = experiment.tests.some((test) => {\n\n        if ((state.filters.ids.length && state.filters.ids.indexOf(test.id) === -1) ||\n            (state.filters.grep && !state.filters.grep.test(test.title))) {\n\n            return false;\n        }\n\n        if (!test.options.skip && test.fn) {\n            return true;\n        }\n    });\n\n    return hasTests;\n};\n\n\ninternals.collectDeps = function (experiment, key) {\n\n    const set = [];\n\n    // if we are looking at afterEaches, we want to run our parent's blocks before ours (unshift onto front)\n    const arrayAddFn = key === 'afterEaches' ? Array.prototype.unshift : Array.prototype.push;\n\n    if (experiment.parent) {\n        arrayAddFn.apply(set, internals.collectDeps(experiment.parent, key));\n    }\n\n    arrayAddFn.apply(set, experiment[key] || []);\n    return set;\n};\n\n\ninternals.cleanupItem = function (err, item, activeDomain, callback) {\n\n    const immed = setImmediate(() => {\n\n        if (!item.onCleanup) {\n            /* $lab:coverage:off$ */\n            // Don't hold on to objects in the active domain.\n            if (activeDomain) {\n                activeDomain.remove(immed);\n            }\n            /* $lab:coverage:on$ */\n\n            return callback(err);\n        }\n\n        item.onCleanup(() => {\n\n            /* $lab:coverage:off$ */\n            // Don't hold on to objects in the active domain.\n            if (activeDomain) {\n                activeDomain.remove(immed);\n            }\n            /* $lab:coverage:on$ */\n\n            callback(err);\n        });\n    });\n\n    /* $lab:coverage:off$ */\n    if (activeDomain) {\n        // The previously active domain need to be used here in case the callback throws.\n        // This is of course only valid if lab itself is ran in a domain, which is the case for its own tests.\n        activeDomain.add(immed);\n    }\n    /* $lab:coverage:on$ */\n};\n\n\ninternals.createItemTimeout = (item, ms, finish) => {\n\n    return setTimeout(() => {\n\n        const error = new Error('Timed out (' + ms + 'ms) - ' + item.title);\n        error.timeout = true;\n        finish(error, 'timeout');\n    }, ms);\n};\n\n\ninternals.createDomainErrorHandler = (item, state, domain, domains, finish) => {\n\n    return (err, isForward) => {\n\n        // 1. Do not forward what's already a forward.\n        // 2. Only errors that reach before*/after* are worth forwarding, otherwise we know where they came from.\n\n        if (!isForward &&\n            item.id === undefined) {\n\n            internals.forwardError(err, domain, domains);\n        }\n\n        if (state.options.debug) {\n            state.report.errors.push(err);\n        }\n\n        finish(err, 'error');\n    };\n};\n\n\ninternals.protect = function (item, state, callback) {\n\n    let isFirst = true;\n    let timeoutId;\n    let countBefore = -1;\n    let failedWithUnhandledRejection = false;\n\n    if (state.options.assert && state.options.assert.count) {\n        countBefore = state.options.assert.count();\n    }\n\n    const activeDomain = Domain.active;\n\n    // We need to keep a reference to the list of domains at the time of the call since those will change with nested\n    // experiments.\n    const domains = state.domains;\n\n    const finish = function (err, cause) {\n\n        clearTimeout(timeoutId);\n        timeoutId = null;\n        setImmediate(() => process.removeListener('unhandledRejection', promiseRejectionHandler));\n        if (failedWithUnhandledRejection) {\n            return;\n        }\n\n        if (state.options.assert && state.options.assert.count) {\n            item.assertions = state.options.assert.count() - countBefore;\n        }\n\n        if (err && err instanceof Error === false) {\n            const data = err;\n            err = new Error('Non Error object received or caught');\n            err.data = data;\n        }\n\n        if (item.options.plan !== undefined && item.options.plan !== item.assertions) {\n            const planMessage = (item.assertions === undefined)\n                ? `Expected ${item.options.plan} assertions, but no assertion library found`\n                : `Expected ${item.options.plan} assertions, but found ${item.assertions}`;\n            if (err && !/^Expected \\d+ assertions/.test(err.message)) {\n                err.message = planMessage + ': ' + err.message;\n            }\n            else {\n                err = new Error(planMessage);\n            }\n\n            state.report.errors.push(err);\n        }\n\n        if (!isFirst) {\n            const message = `Multiple callbacks or thrown errors received in test \"${item.title}\" (${cause})`;\n\n            if (err && !/^Multiple callbacks/.test(err.message)) {\n                err.message = message + ': ' + err.message;\n            }\n            else {\n                err = new Error(message);\n            }\n\n            state.report.errors.push(err);\n            return;\n        }\n        isFirst = false;\n        internals.cleanupItem(err, item, activeDomain, callback);\n    };\n\n    const ms = item.options.timeout !== undefined ? item.options.timeout : state.options.timeout;\n    if (ms) {\n        timeoutId = internals.createItemTimeout(item, ms, finish);\n    }\n\n    const domain = Domain.createDomain();\n    const onError = internals.createDomainErrorHandler(item, state, domain, domains, finish);\n\n    domain.title = item.title;\n    domain.on('error', onError);\n    domains.push(domain);\n\n    const promiseRejectionHandler = function (reason) {\n\n        finish(reason, 'unhandledRejection');\n        failedWithUnhandledRejection = true;\n    };\n\n    if (state.options.rejections) {\n        process.on('unhandledRejection', promiseRejectionHandler);\n    }\n\n    setImmediate(() => {\n\n        domain.enter();\n\n        item.onCleanup = null;\n        const onCleanup = (func) => {\n\n            item.onCleanup = func;\n        };\n\n        const done = (err) => {\n\n            finish(err, 'done');\n        };\n\n        item.notes = [];\n        done.note = (note) => {\n\n            item.notes.push(note);\n        };\n\n        const itemResult = item.fn.call(null, done, onCleanup);\n\n        if (itemResult &&\n            itemResult.then instanceof Function) {\n\n            itemResult.then(() => finish(null), (err) => finish(err, 'done'));\n        }\n        else if (!item.fn.length) {\n            finish(new Error(`Function for \"${item.title}\" should either take a callback argument or return a promise`), 'function signature');\n        }\n\n        domain.exit();\n    });\n};\n\n\ninternals.forwardError = function (err, sourceDomain, targetDomains) {\n\n    for (let i = 0; i < targetDomains.length; ++i) {\n        const d = targetDomains[i];\n        if (d !== sourceDomain) {\n            d.emit('error', err, true); // Add true to mark this as a forward.\n        }\n    }\n};\n\n\ninternals.count = function (experiments, state) {\n\n    state.count = state.count || 0;\n    state.seq = state.seq || 0;\n\n    for (let i = 0; i < experiments.length; ++i) {\n        const experiment = experiments[i];\n\n        for (let j = 0; j < experiment.tests.length; ++j) {\n            const test = experiment.tests[j];\n            test.id = ++state.seq;\n            state.count += (state.filters.ids.length && state.filters.ids.indexOf(test.id) === -1) || (state.filters.grep && !state.filters.grep.test(test.title)) ? 0 : 1;\n        }\n\n        internals.count(experiment.experiments, state);\n    }\n\n    return state.count;\n};\n\n\ninternals.fail = function (experiments, state, skip, err) {\n\n    for (let i = 0; i < experiments.length; ++i) {\n        const experiment = experiments[i];\n\n        for (let j = 0; j < experiment.tests.length; ++j) {\n            internals.failTest(experiment.tests[j], state, skip, err);\n        }\n\n        internals.fail(experiment.experiments, state, skip || experiment.options.skip);\n    }\n};\n\n\ninternals.failTest = function (test, state, skip, err) {\n\n    if (!test.fn ||\n        skip ||\n        test.options.skip) {\n\n        test[test.fn ? 'skipped' : 'todo'] = true;\n    }\n    else {\n        state.report.failures++;\n        test.err = err;\n    }\n\n    test.duration = 0;\n    state.report.tests.push(test);\n    state.reporter.test(test);\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/reporters/index.js":"'use strict';\n\n// Load modules\n\nconst Fs = require('fs');\nconst Path = require('path');\nconst Mkdirp = require('mkdirp');\n// ('./multiple') loaded below\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.protos = {\n    clover: require('./clover'),\n    console: require('./console'),\n    html: require('./html'),\n    json: require('./json'),\n    junit: require('./junit'),\n    lcov: require('./lcov'),\n    tap: require('./tap')\n};\n\n\ninternals.requireReporter = function (reporter) {\n\n    if (Array.isArray(reporter)) {\n        return require('./multiple');\n    }\n\n    if (reporter[0] === '.') {\n        return require(Path.join(process.cwd(), reporter));\n    }\n\n    return require(reporter);\n};\n\n\ninternals.isOverLintStatus = function (lint, threshold, status) {\n\n    if (threshold >= 0) {\n        const lintResults = lint.lint;\n\n        for (let i = 0; i < lintResults.length; ++i) {\n\n            const errors = lintResults[i].errors;\n\n            for (let j = 0; j < errors.length; ++j) {\n                if (errors[j].severity === status && --threshold <= 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n};\n\n\nexports.generate = function (options) {\n\n    if (Array.isArray(options.reporter) && options.reporter.length === 1) {\n        options.reporter = options.reporter[0];\n    }\n\n    if (Array.isArray(options.output) && options.output.length === 1) {\n        options.output = options.output[0];\n    }\n\n    const Proto = internals.protos[options.reporter] || internals.requireReporter(options.reporter);\n    const reporter = new Proto(options);\n\n    if (!Array.isArray(options.reporter)) {\n        let dest;\n        if (typeof options.output === 'string') {\n            Mkdirp.sync(Path.dirname(options.output));\n            dest = Fs.createWriteStream(options.output);\n        }\n        else {\n            dest = options.output;\n        }\n\n        let output = '';\n\n        reporter.report = function (text) {\n\n            output += text;\n            if (dest) {\n                dest.write(text);\n            }\n        };\n\n        reporter.finalize = function (notebook, callback) {\n\n            reporter.end(notebook);\n\n            const finalize = function () {\n\n                const code = ((notebook.errors && notebook.errors.length) ||                                                  // Before/after/exceptions\n                            options.coverage && options.threshold && notebook.coverage.percent < options.threshold) ||        // Missing coverage\n                            notebook.failures ||                                                                              // Tests failed\n                            (notebook.leaks && notebook.leaks.length) ||                                                      // Global leaked\n                            (options.lint &&\n                                (internals.isOverLintStatus(notebook.lint, options['lint-errors-threshold'], 'ERROR') ||      // Linting errors\n                                internals.isOverLintStatus(notebook.lint, options['lint-warnings-threshold'], 'WARNING')      // Linting warnings\n                            )) ? 1 : 0;\n\n                if (callback) {\n                    return callback(null, code, output);\n                }\n\n                // Flush the buffered output before exiting\n                process.stdout.write('', () => process.exit(code));\n            };\n\n            if (!dest || dest === process.stdout) {\n                return finalize();\n            }\n\n            dest.end(finalize);\n        };\n    }\n\n    return reporter;\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/reporters/clover.js":"'use strict';\n\n// Load modules\n\nconst Fs = require('fs');\nconst Path = require('path');\nconst Handlebars = require('handlebars');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Reporter = function (options) {\n\n    this.settings = options;\n\n    const filename = Path.join(__dirname, 'clover', 'report.xml');\n    const template = Fs.readFileSync(filename, 'utf8');\n\n    if (this.settings.coveragePath) {\n        this.settings.packageRoot = Path.basename(this.settings.coveragePath);\n    }\n    else {\n        this.settings.packageRoot = 'root';\n    }\n\n    Handlebars.registerHelper('hits', (hits) => {\n\n        return (hits === undefined ? '0' : hits);\n    });\n\n    this.view = Handlebars.compile(template);\n};\n\n\ninternals.Reporter.prototype.start = function (notebook) {\n\n};\n\n\ninternals.Reporter.prototype.test = function (test) {\n\n};\n\n\ninternals.Reporter.prototype.end = function (notebook) {\n\n    const settings = this.settings;\n\n    notebook.coverage = notebook.coverage || { files: [] };\n    const context = {\n        cov: notebook.coverage,\n        now: Date.now(),\n        fileCount: notebook.coverage.files.length,\n        packageCount: 0,\n        packages: {}\n    };\n\n    notebook.coverage.files.forEach((file) => {\n\n        file.segments = file.filename.split('/');\n        file.basename = file.segments.pop();\n        file.coveredlines = 0;\n\n        if (file.segments.length) {\n            file.dirname = file.segments.join('/') + '/';\n            file.package = settings.packageRoot + '.' + file.segments.join('.');\n        }\n        else {\n            file.package = settings.packageRoot;\n        }\n\n\n        if (!context.packages[file.package]) {\n            context.packages[file.package] = {\n                files: [],\n                hits: 0,\n                misses: 0,\n                sloc: 0,\n                percent: 0\n            };\n            context.packageCount++;\n        }\n\n        const curPackage = context.packages[file.package];\n\n        curPackage.files.push(file);\n        curPackage.hits += file.hits;\n        curPackage.misses += file.misses;\n        curPackage.sloc += file.sloc;\n        curPackage.percent = curPackage.hits / curPackage.sloc;\n\n    });\n\n    this.report(this.view(context));\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/reporters/console.js":"'use strict';\n\n// Load modules\n\nconst Tty = require('tty');\nconst Diff = require('diff');\nconst StringifySafe = require('json-stringify-safe');\nconst StableStringify = require('json-stable-stringify');\n\n\n// Declare internals\n\nconst internals = {\n    width: 50\n};\n\ninternals.stringify = (obj, serializer, indent) => {\n\n    return StableStringify(obj,\n      { space: indent, replacer: StringifySafe.getSerialize(serializer) });\n};\n\nexports = module.exports = internals.Reporter = function (options) {\n\n    this.settings = options;\n    this.count = 0;\n    this.last = [];\n\n    this.colors = internals.colors(options.colors);\n};\n\n\ninternals.Reporter.prototype.start = function (notebook) {\n\n};\n\n\ninternals.Reporter.prototype.test = function (test) {\n\n    if (this.settings.progress === 0) {\n        return;\n    }\n\n    if (this.settings['silent-skips'] && (test.skipped || test.todo)) {\n        return;\n    }\n\n    if (this.settings.progress === 1) {\n\n        // ..x....x.-..\n\n        if (!this.count) {\n            this.report('\\n  ');\n        }\n\n        this.count++;\n\n        if ((this.count - 1) % internals.width === 0) {\n            this.report('\\n  ');\n        }\n\n        this.report(test.err ? this.colors.red('x') : (test.skipped || test.todo ? this.colors.magenta('-') : '.'));\n    }\n    else {\n\n        // Can't be fully covereed but it's ok\n        // $lab:coverage:off$\n        const check = process.platform === 'win32' ? '\\u221A' : '\\u2714';\n        const asterisk = process.platform === 'win32' ? '\\u00D7' : '\\u2716';\n        // $lab:coverage:on$\n\n        // Verbose (Spec reporter)\n\n        for (let i = 0; i < test.path.length; ++i) {\n            if (test.path[i] !== this.last[i] || (i > 0 && test.path[i - 1] !== this.last[i - 1])) {\n                this.report(internals.spacer(i * 2) + test.path[i] + '\\n');\n            }\n        }\n\n        this.last = test.path;\n\n        const spacer = internals.spacer(test.path.length * 2);\n        if (test.err) {\n            this.report(spacer + this.colors.red(asterisk + ' ' + test.id + ') ' + test.relativeTitle) + '\\n');\n        }\n        else {\n            const symbol = test.skipped || test.todo ? this.colors.magenta('-') : this.colors.green(check);\n            const assertion = test.assertions === undefined ? '' : ' and ' + test.assertions + ' assertions';\n            this.report(spacer + symbol + ' ' + this.colors.gray(test.id + ') ' + test.relativeTitle +\n                ' (' + test.duration + ' ms' + assertion + ')') + '\\n');\n        }\n    }\n};\n\n\ninternals.spacer = function (length) {\n\n    return new Array(length + 1).join(' ');\n};\n\n\ninternals.stringifyReplacer = function (key, value) {\n\n    // Show usually invisible values from JSON.stringify in a different way,\n    // follow the bracket format of json-stringify-safe.\n\n    if (value === undefined) {\n        return '[undefined]';\n    }\n\n    if (typeof value === 'function' || value === Infinity || value === -Infinity) {\n        return '[' + value.toString() + ']';\n    }\n\n    /* $lab:coverage:off$ */ // There is no way to cover that in node 0.10\n    if (typeof value === 'symbol') {\n        return '[' + value.toString() + ']';\n    }\n    /* $lab:coverage:on$ */\n\n    return value;\n};\n\n\ninternals.Reporter.prototype.end = function (notebook) {\n\n    if (this.settings.progress) {\n        this.report('\\n\\n');\n    }\n\n    // Colors\n\n    const red = this.colors.red;\n    const green = this.colors.green;\n    const gray = this.colors.gray;\n    const yellow = this.colors.yellow;\n    const whiteRedBg = this.colors.whiteRedBg;\n    const blackGreenBg = this.colors.blackGreenBg;\n\n    // Tests\n\n    const notes = notebook.tests.filter(internals.filterNotes);\n\n    const failures = notebook.tests.filter(internals.filterFailures);\n\n    const skipped = notebook.tests.filter(internals.filterSkipped);\n\n    let output = '';\n    const totalTests = notebook.tests.length - skipped.length;\n\n    const errors = notebook.errors || [];\n    if (errors.length) {\n        output += 'Test script errors:\\n\\n';\n        errors.forEach((err) => {\n\n            output += red(err.message) + '\\n';\n            if (err.stack) {\n                const stack = err.stack.slice(err.stack.indexOf('\\n') + 1)\n                                       .replace(/^/gm, '  ')\n                                       .split('\\n')\n                                       .filter(internals.filterNodeModules)               // Remove node_modules files\n                                       .slice(0, 5)                                       // Show only first 5 stack lines\n                                       .join('\\n');\n\n                output += gray(stack) + '\\n';\n            }\n\n            output += '\\n';\n        });\n        output += red('There were ' + errors.length + ' test script error(s).') + '\\n\\n';\n    }\n\n    if (failures.length) {\n        output += 'Failed tests:\\n\\n';\n\n        for (let i = 0; i < failures.length; ++i) {\n            const test = failures[i];\n            const message = test.err.message || '';\n\n            output += '  ' + test.id + ') ' + test.title + ':\\n\\n';\n\n            // Actual vs Expected\n\n            if (test.err.actual !== undefined &&\n                test.err.expected !== undefined) {\n\n                const actual = internals.stringify(test.err.actual, internals.stringifyReplacer, 2);\n                const expected = internals.stringify(test.err.expected, internals.stringifyReplacer, 2);\n\n                output += '      ' + whiteRedBg('actual') + ' ' + blackGreenBg('expected') + '\\n\\n      ';\n\n                const comparison = Diff.diffWords(actual, expected);\n                for (let j = 0; j < comparison.length; ++j) {\n                    const item = comparison[j];\n                    const value = item.value;\n                    const lines = value.split('\\n');\n                    for (let k = 0; k < lines.length; ++k) {\n                        if (k) {\n                            output += '\\n      ';\n                        }\n\n                        if (item.added || item.removed) {\n                            output += item.added ? blackGreenBg(lines[k]) : whiteRedBg(lines[k]);\n                        }\n                        else {\n                            output += lines[k];\n                        }\n                    }\n                }\n\n                output += '\\n\\n      ' + yellow(message);\n                output += '\\n\\n';\n            }\n            else {\n                output += '      ' + red(message) + '\\n\\n';\n            }\n\n            if (test.err.at) {\n                output += gray('      at ' + test.err.at.filename + ':' + test.err.at.line + ':' + test.err.at.column) + '\\n';\n            }\n            else if (!test.timeout &&\n                test.err.stack) {\n\n                output += gray(test.err.stack.slice(test.err.stack.indexOf('\\n') + 1).replace(/^/gm, '  ')) + '\\n';\n            }\n\n            if (test.err.data) {\n                const isObject = typeof test.err.data === 'object' && !Array.isArray(test.err.data);\n                let errorData = internals.stringify(test.err.data, null, isObject ? 4 : null);\n                if (isObject) {\n                    errorData = errorData.replace(/(\\n\\s*)\"(.*)\"\\:/g, '$1$2:').split('\\n').slice(1, -1).join('\\n');\n                }\n\n                output += gray('\\n      Additional error data:\\n' + errorData.replace(/^/gm, '      ')) + '\\n';\n            }\n\n            output += '\\n';\n        }\n\n        output += '\\n' + red(failures.length + ' of ' + totalTests + ' tests failed');\n    }\n    else {\n        output += green(totalTests + ' tests complete');\n    }\n    if (skipped.length) {\n        output += gray(` (${skipped.length} skipped)`);\n    }\n    output += '\\n';\n    output += 'Test duration: ' + notebook.ms + ' ms\\n';\n\n    // Assertions\n\n    if (notebook.assertions !== undefined) {\n        output += 'Assertions count: ' + notebook.assertions + ' (verbosity: ' + (notebook.assertions / totalTests).toFixed(2) + ')\\n';\n    }\n\n    // Leaks\n\n    if (notebook.leaks) {\n        if (notebook.leaks.length) {\n            output += red('The following leaks were detected:' + notebook.leaks.join(', ')) + '\\n';\n        }\n        else {\n            output += green('No global variable leaks detected') + '\\n';\n        }\n    }\n\n    if (notebook.shuffle) {\n        output += 'Randomized with seed: ' + notebook.seed + '. Use --shuffle --seed ' + notebook.seed + ' to run tests in same order again.\\n';\n    }\n\n    // Coverage\n\n    const coverage = notebook.coverage;\n    if (coverage) {\n        const status = 'Coverage: ' + coverage.percent.toFixed(2) + '%';\n\n        output += coverage.percent === 100 ? green(status) : red(status + ' (' + (coverage.sloc - coverage.hits) + '/' + coverage.sloc + ')');\n        if (coverage.percent < 100) {\n            coverage.files.forEach((file) => {\n\n                let missingLines;\n                if (file.sourcemaps) {\n                    const missingLinesByFile = {};\n                    Object.keys(file.source).forEach((lineNumber) => {\n\n                        const line = file.source[lineNumber];\n                        if (line.miss) {\n                            missingLines = missingLinesByFile[line.originalFilename] = missingLinesByFile[line.originalFilename] || [];\n                            missingLines.push(line.originalLine);\n                        }\n                    });\n\n                    const files = Object.keys(missingLinesByFile);\n                    if (files.length) {\n                        output += red('\\n' + file.filename + ' missing coverage from file(s):');\n                        files.forEach((filename) => {\n\n                            output += red('\\n\\t' + filename + ' on line(s): ' + missingLinesByFile[filename].join(', '));\n                        });\n                    }\n                }\n                else {\n                    missingLines = [];\n                    Object.keys(file.source).forEach((lineNumber) => {\n\n                        const line = file.source[lineNumber];\n                        if (line.miss) {\n                            missingLines.push(lineNumber);\n                        }\n                    });\n\n                    if (missingLines.length) {\n                        output += red('\\n' + file.filename + ' missing coverage on line(s): ' + missingLines.join(', '));\n                    }\n                }\n            });\n\n            if (coverage.percent < this.settings.threshold || isNaN(coverage.percent)) {\n                output += red('\\nCode coverage below threshold: ' + coverage.percent.toFixed(2) + ' < ' + this.settings.threshold);\n            }\n        }\n\n        output += '\\n';\n    }\n\n    const lint = notebook.lint;\n    if (lint) {\n        output += 'Linting results:';\n\n        let hasErrors = false;\n        lint.lint.forEach((entry) => {\n\n            // Don't show anything if there aren't issues\n            if (!entry.errors || !entry.errors.length) {\n                return;\n            }\n\n            hasErrors = true;\n            output += gray('\\n\\t' + entry.filename + ':');\n            entry.errors.forEach((err) => {\n\n                output += (err.severity === 'ERROR' ? red : yellow)('\\n\\t\\tLine ' + err.line + ': ' + err.message);\n            });\n        });\n\n        if (!hasErrors) {\n            output += green(' No issues\\n');\n        }\n    }\n\n    if (notes.length) {\n        output += '\\n\\nTest notes:\\n';\n        notes.forEach((test) => {\n\n            output += gray(test.relativeTitle) + '\\n';\n            test.notes.forEach((note) => {\n\n                output += yellow(`\\t* ${note}`);\n            });\n        });\n    }\n\n    output += '\\n';\n    this.report(output);\n};\n\n\ninternals.color = function (name, code, enabled) {\n\n    if (enabled && Array.isArray(code)) {\n        const color = '\\u001b[' + code[0] + ';' + code[1] + 'm';\n        return function (text) {\n\n            return color + text + '\\u001b[0m';\n        };\n    }\n    else if (enabled) {\n        const color = '\\u001b[' + code + 'm';\n        return function (text) {\n\n            return color + text + '\\u001b[0m';\n        };\n    }\n\n    return function (text) {\n\n        return text;\n    };\n};\n\n\ninternals.colors = function (enabled) {\n\n    if (enabled === null) {\n        enabled = Tty.isatty(1) && Tty.isatty(2);\n    }\n\n    const codes = {\n        'black': 0,\n        'gray': 92,\n        'red': 31,\n        'green': 32,\n        'yellow': 33,\n        'magenta': 35,\n        'redBg': 41,\n        'greenBg': 42,\n        'whiteRedBg': [37, 41],\n        'blackGreenBg': [30, 42]\n    };\n\n    const colors = {};\n    const names = Object.keys(codes);\n    for (let i = 0; i < names.length; ++i) {\n        const name = names[i];\n        colors[name] = internals.color(name, codes[name], enabled);\n    }\n\n    return colors;\n};\n\n\ninternals.filterNotes = function (test) {\n\n    return test.notes && test.notes.length;\n};\n\n\ninternals.filterFailures = function (test) {\n\n    return !!test.err;\n};\n\n\ninternals.filterNodeModules = function (line) {\n\n    return !(/\\/node_modules\\//.test(line));\n};\n\n\ninternals.filterSkipped = function (test) {\n\n    return test.skipped || test.todo;\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/reporters/html.js":"'use strict';\n\n// Load modules\n\nconst Fs = require('fs');\nconst Path = require('path');\nconst Handlebars = require('handlebars');\nconst Hoek = require('hoek');\nconst SourceMapSupport = require('source-map-support');\nconst SourceMapConsumer = require('source-map').SourceMapConsumer;\nconst SourceNode = require('source-map').SourceNode;\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Reporter = function (options) {\n\n    this.settings = options;\n\n    const filename = Path.join(__dirname, 'html', 'report.html');\n    const template = Fs.readFileSync(filename, 'utf8');\n\n    // Display all valid numbers except zeros\n    Handlebars.registerHelper('number', (number) => {\n\n        return +number || '';\n    });\n\n    Handlebars.registerHelper('join', (array, separator) => {\n\n        return array.join(separator);\n    });\n\n    Handlebars.registerHelper('replace', (str, from, to, flags) => {\n\n        return str.replace(new RegExp(from, flags), to);\n    });\n\n    Handlebars.registerHelper('lintJoin', (array) => {\n\n        let str = '';\n\n        for (let i = 0; i < array.length; ++i) {\n            if (str) {\n                str += '&#xa;'; // This is a line break\n            }\n\n            str += Hoek.escapeHtml(array[i]); // Handlebars' escape is just not enough\n        }\n\n        return new Handlebars.SafeString(str);\n    });\n\n    Handlebars.registerHelper('errorMessage', (err) => {\n\n        return new Handlebars.SafeString(Hoek.escapeHtml('' + err.message));\n    });\n\n    Handlebars.registerHelper('errorStack', (err) => {\n\n        const stack = err.stack.slice(err.stack.indexOf('\\n') + 1).replace(/^\\s*/gm, '  ');\n        return new Handlebars.SafeString(Hoek.escapeHtml(stack));\n    });\n\n    const partialsPath = Path.join(__dirname, 'html', 'partials');\n    const partials = Fs.readdirSync(partialsPath);\n    partials.forEach((partial) => {\n\n        Handlebars.registerPartial(Path.basename(partial, '.html'), Fs.readFileSync(Path.join(partialsPath, partial), 'utf8'));\n    });\n\n    this.view = Handlebars.compile(template);\n};\n\n\ninternals.Reporter.prototype.start = function (notebook) {\n\n};\n\n\ninternals.Reporter.prototype.test = function (test) {\n\n};\n\n\ninternals.Reporter.prototype.end = function (notebook) {\n\n    notebook.coverage = notebook.coverage || { percent: 0, files: [] };\n    notebook.lint = notebook.lint || { lint: [], disabled: true };\n\n    const percent = notebook.coverage.percent;\n    const context = {\n        coverage: {\n            cov: notebook.coverage,\n            percentClass: percent > 75 ? 'high' : (percent > 50 ? 'medium' : (percent > 25 ? 'low' : 'terrible')),\n            percent: (percent % 1 === 0) ? percent.toFixed() : percent.toFixed(2)\n        },\n        lint: notebook.lint,\n        tests: notebook.tests || [],\n        errors: notebook.errors || [],\n        duration: notebook.ms\n    };\n\n    context.failures = context.tests.filter((test) => {\n\n        return !!test.err;\n    });\n\n    context.skipped = context.tests.filter((test) => {\n\n        return test.skipped;\n    });\n\n    // Populate path to be used for filtering\n    context.paths = [];\n    context.tests.forEach((test) => {\n\n        const paths = [];\n        test.path.forEach((path) => {\n\n            path = path.replace(/\\ /gi, '_');\n            paths.push(path);\n            if (context.paths.indexOf(path) === -1) {\n                context.paths.push(path);\n            }\n        });\n\n        test.path = paths;\n    });\n\n    // if we have sourcemaps, we might have different source files.\n    // let's replace existing files with original files\n    context.coverage.cov.files = Hoek.flatten(context.coverage.cov.files.map((file) => {\n\n        if (!file.sourcemaps) {\n            // return untouched file\n            return file;\n        }\n\n        const descriptors = {};\n        const generatedContent = Object.keys(file.source).map((k) => file.source[k].source).join('\\n');\n\n        // Rather than relying on generated content, get the nodes tree from sourcemap consumer\n        const sourcemap = SourceMapSupport.retrieveSourceMap(file.filename).map;\n        const smc = new SourceMapConsumer(sourcemap);\n\n        // For each original files that might have been transformed into this generate content, store a new descriptor\n        SourceNode.fromStringWithSourceMap(generatedContent, smc).walkSourceContents((sourceFile, content) => {\n\n            descriptors[sourceFile] = {\n                generated: file.filename,\n                filename: sourceFile,\n                source: {}\n            };\n\n            content.split('\\n').forEach((line, number) => {\n\n                descriptors[sourceFile].source[number + 1] = {\n                    source: line,\n                    // consider line covered by default\n                    hits: undefined,\n                    miss: false\n                };\n            });\n        });\n\n        // Now maps coverage information to original files\n        Object.keys(file.source).forEach((generatedLine) => {\n\n            const source = file.source[generatedLine];\n\n            // Affect hits and misses to entire lines\n            if (source.originalFilename in descriptors) {\n                const target = descriptors[source.originalFilename].source[source.originalLine];\n                target.miss = source.miss;\n                target.hits = source.hits;\n            }\n\n            if (!source.chunks) {\n                return;\n            }\n\n            // The same generated line might have chunks from different original files/lines:\n            // [{originalLine: 8, originalColumn: 0}, {originalLine: 13, originalColumn: 12}, {originalLine: 13, originalColumn: 4}]\n            // We must group them by original files, then by lines\n            const groupsByFiles = {};\n            source.chunks.forEach((chunk) => {\n\n                if (!(chunk.originalFilename in groupsByFiles)) {\n                    groupsByFiles[chunk.originalFilename] = [];\n                }\n                const groups = groupsByFiles[chunk.originalFilename];\n\n                if (!(chunk.originalLine in groups)) {\n                    groups[chunk.originalLine] = [];\n                }\n                groups[chunk.originalLine].push(chunk);\n            });\n\n            // Now that all chunks are properly grouped, we order them by columns and copy them to original descriptors\n            for (const originalFilename in groupsByFiles) {\n                const groups = groupsByFiles[originalFilename];\n\n                for (const originalLine in groups) {\n                    const chunks = groups[originalLine].sort((a, b) => a.originalColumn - b.originalColumn);\n\n                    const target = descriptors[originalFilename].source[originalLine];\n                    target.chunks = chunks.map((chunk, n) => {\n\n                        // First chunk of each line always starts at 0\n                        const start = n === 0 ? 0  : chunk.originalColumn;\n                        // Column of chunk N is the end column of chunk N-1\n                        const end = chunks[n + 1] && chunks[n + 1].originalColumn;\n                        return Object.assign({}, chunk, {\n                            // Override the source line to only include the original slice for that chunk\n                            source: target.source.slice(start, end)\n                        });\n                    });\n                    target.miss = true;\n                }\n            }\n\n        });\n\n        // Return original file descriptors (that will be flatten next) and generated file as well\n        return Object.keys(descriptors).map((key) => descriptors[key]).concat([file]);\n    }));\n\n    context.coverage.cov.files.forEach((file) => {\n\n        file.segments = file.filename.split('/');\n        file.basename = file.segments.pop();\n        if (file.percent >= 0) {\n            file.percent = (file.percent % 1 === 0) ? file.percent.toFixed() : file.percent.toFixed(2);\n            file.percentClass = file.percent > 75 ? 'high' : (file.percent > 50 ? 'medium' : (file.percent > 25 ? 'low' : 'terrible'));\n        }\n        else {\n            file.percentClass = 'hide';\n        }\n\n        if (file.segments.length) {\n            file.dirname = file.segments.join('/') + '/';\n        }\n\n        if (context.lint.lint.length) {\n            const fileLint = internals.findLint(context.lint.lint, file);\n            if (fileLint) {\n                Object.keys(file.source).forEach((line) => {\n\n                    file.source[line].lintErrors = internals.findLintErrors(fileLint, +line);\n                });\n            }\n        }\n    });\n\n    if (!context.lint.disabled) {\n        context.lint.errorClass = internals.lintClass(context.lint.totalErrors, this.settings['lint-errors-threshold']);\n        context.lint.warningClass = internals.lintClass(context.lint.totalWarnings, this.settings['lint-warnings-threshold']);\n\n        context.lint.lint.forEach((entry) => {\n\n            entry.filename = Path.relative(process.cwd(), Path.resolve(entry.filename));\n            entry.errorClass = internals.lintClass(entry.totalErrors, this.settings['lint-errors-threshold']);\n            entry.warningClass = internals.lintClass(entry.totalWarnings, this.settings['lint-warnings-threshold']);\n\n            entry.errors.forEach((err) => {\n\n                err.message = Hoek.escapeHtml(err.message);\n            });\n        }, this);\n    }\n\n    this.report(this.view(context));\n};\n\ninternals.findLint = function (lint, file) {\n\n    for (let i = 0; i < lint.length; ++i) {\n        if (lint[i].filename.replace(/\\\\/g, '/').slice(-file.filename.length) === file.filename && lint[i].errors.length) {\n            return lint[i];\n        }\n    }\n};\n\ninternals.findLintErrors = function (lint, line) {\n\n    const reports = { errors: [], warnings: [] };\n    for (let i = 0; i < lint.errors.length; ++i) {\n        const report = lint.errors[i];\n        if (report.line === line) {\n\n            if (report.severity === 'ERROR') {\n                reports.errors.push(report.message);\n            }\n            else {\n                reports.warnings.push(report.message);\n            }\n        }\n    }\n\n    return reports.errors.length || reports.warnings.length ? reports : undefined;\n};\n\ninternals.lintClass = function (count, threshold) {\n\n    return count > threshold ? 'low' : (count > 0 ? 'medium' : 'high');\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/reporters/json.js":"'use strict';\n\n// Load modules\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Reporter = function (options) {\n\n    this.settings = options;\n};\n\n\ninternals.Reporter.prototype.start = function (notebook) {\n\n};\n\n\ninternals.Reporter.prototype.test = function (test) {\n\n};\n\n\ninternals.Reporter.prototype.end = function (notebook) {\n\n    const tests = {};\n    notebook.tests.forEach((test) => {\n\n        const path = test.path.join('/');\n        tests[path] = tests[path] || [];\n        tests[path].push({\n            title: test.relativeTitle,\n            err: (test.err ? test.err.message : false),\n            duration: test.duration\n        });\n    });\n\n    const report = {\n        tests,\n        duration: notebook.ms,\n        leaks: notebook.leaks\n    };\n\n    if (notebook.errors.length) {\n        report.errors = notebook.errors;\n    }\n\n    if (notebook.coverage) {\n        report.coverage = notebook.coverage;\n    }\n\n    if (notebook.lint && notebook.lint.lint) {\n        report.lint = notebook.lint.lint;\n    }\n\n    this.report(JSON.stringify(report, null, 2));\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/reporters/junit.js":"'use strict';\n\n// Load modules\n\nconst Fs = require('fs');\nconst Path = require('path');\nconst Handlebars = require('handlebars');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Reporter = function (options) {\n\n    this.settings = options;\n\n    const filename = Path.join(__dirname, 'junit', 'report.xml');\n    const template = Fs.readFileSync(filename, 'utf8');\n    this.view = Handlebars.compile(template);\n\n};\n\n\ninternals.Reporter.prototype.start = function (notebook) {\n\n};\n\n\ninternals.Reporter.prototype.test = function (test) {\n\n};\n\n\ninternals.Reporter.prototype.end = function (notebook) {\n\n    const context = {\n        count: notebook.tests.length,\n        failures: notebook.failures,\n        errors: notebook.errors.length,\n        skipped: 0,\n        time: notebook.ms / 1000\n    };\n\n    const tests = context.tests = [];\n\n    notebook.tests.forEach((nbtest) => {\n\n        const test = {\n            title: nbtest.title,\n            path: nbtest.path.join(' '),\n            relativeTitle: nbtest.relativeTitle,\n            time: nbtest.duration / 1000\n        };\n\n        if (nbtest.skipped || nbtest.todo) {\n\n            test.skipped = true;\n            ++context.skipped;\n        }\n\n        if (nbtest.err) {\n\n            test.err = {\n                name: nbtest.err.name,\n                message: nbtest.err.message,\n                details: nbtest.err.stack\n            };\n        }\n\n        tests.push(test);\n    });\n\n    this.report(this.view(context));\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/reporters/lcov.js":"'use strict';\n\n// Load modules\n\nconst Path = require('path');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Reporter = function (options) {\n\n    this.settings = options;\n};\n\n\ninternals.Reporter.prototype.reportln = function (line) {\n\n    this.report(line + '\\n');\n};\n\n\ninternals.Reporter.prototype.start = function (notebook) {\n\n};\n\n\ninternals.Reporter.prototype.test = function (test) {\n\n};\n\n\ninternals.Reporter.prototype.end = function (notebook) {\n\n    notebook.coverage = notebook.coverage || { files: [] };\n    notebook.coverage.files.forEach((file) => {\n\n        this.reportln('TN:');                                                       // Test Name\n        this.reportln('SF:' + Path.join(process.cwd(), '/', file.filename));        // Script File\n\n        const lineNums = Object.keys(file.source);\n        lineNums.forEach((lineNum) => {\n\n            const line = file.source[lineNum];\n            const hits = line.miss ? 0 : (line.hits || 1);\n            this.reportln('DA:' + lineNum + ',' + hits);                            // Line and total execution count\n        });\n\n        this.reportln('LF:' + file.sloc);\n        this.reportln('LH:' + file.hits);\n        this.reportln('end_of_record');\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/reporters/tap.js":"'use strict';\n\n// Load modules\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Reporter = function (options) {\n\n    this.settings = options;\n\n    this.passes = 0;\n    this.failures = 0;\n    this.skipped = 0;\n    this.todo = 0;\n    this.counter = 0;\n};\n\ninternals.Reporter.prototype.insertYAMLBlock = function (test) {\n\n    this.report('  ---\\n');\n    this.report('  duration_ms: ' + test.duration + '\\n');\n    if (test.err && test.err.stack) {\n        this.report('  stack: |-\\n');\n        this.report('    ' + test.err.stack.replace(/(\\n|\\r\\n)/gm, '\\n    ') + '\\n');\n    }\n    this.report('  ...\\n');\n};\n\n\ninternals.Reporter.prototype.start = function (notebook) {\n\n    this.report('TAP version 13\\n');\n    this.report('1..' + notebook.count + '\\n');\n};\n\n\ninternals.Reporter.prototype.test = function (test) {\n\n    const title = '(' + test.id + ') ' + test.title.replace(/#/g, '');\n    const id = ++this.counter;\n\n    if (test.err) {\n        ++this.failures;\n        this.report('not ok ' + id + ' ' + title + '\\n');\n        this.insertYAMLBlock(test);\n    }\n    else if (test.skipped) {\n        ++this.skipped;\n        this.report('ok ' + id + ' # SKIP ' + title + '\\n');\n    }\n    else if (test.todo) {\n        ++this.todo;\n        this.report('ok ' + id + ' # TODO ' + title + '\\n');\n    }\n    else {\n        ++this.passes;\n        this.report('ok ' + id + ' ' + title + '\\n');\n        this.insertYAMLBlock(test);\n    }\n};\n\n\ninternals.Reporter.prototype.end = function (notebook) {\n\n    this.report('# tests ' + (this.passes + this.failures + this.skipped) + '\\n');\n    this.report('# pass ' + this.passes + '\\n');\n    this.report('# fail ' + this.failures + '\\n');\n    this.report('# skipped ' + this.skipped + '\\n');\n    this.report('# todo ' + this.todo + '\\n');\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/lint.js":"'use strict';\n\n// Load modules\n\nconst ChildProcess = require('child_process');\nconst Fs = require('fs');\n\n\n// Declare internals\n\nconst internals = {\n    linter: __dirname + '/linter/index.js'\n};\n\n\nexports.lint = function (settings, callback) {\n\n    const linterPath = (settings.linter && settings.linter !== 'eslint') ? settings.linter : internals.linter;\n\n    let linterOptions;\n\n    try {\n        linterOptions = JSON.parse(settings['lint-options'] || '{}');\n    }\n    catch (err) {\n        throw new Error('lint-options could not be parsed');\n    }\n\n    linterOptions.fix = settings['lint-fix'];\n\n    const child = ChildProcess.fork(linterPath, [JSON.stringify(linterOptions)], { cwd: settings.lintingPath });\n    child.once('message', (message) => {\n\n        child.kill();\n\n        const result = { lint: message, totalErrors: 0, totalWarnings: 0 };\n\n        result.lint.forEach((lint) => {\n\n            let errors = 0;\n            let warnings = 0;\n\n            lint.errors.forEach((err) => {\n\n                if (err.severity === 'ERROR') {\n                    errors++;\n                }\n                else {\n                    warnings++;\n                }\n            });\n\n            lint.totalErrors = errors;\n            lint.totalWarnings = warnings;\n            result.totalErrors += errors;\n            result.totalWarnings += warnings;\n\n            if (lint.fix) {\n                Fs.writeFileSync(lint.filename, lint.fix.output);\n            }\n        });\n\n        result.total = result.totalErrors + result.totalWarnings;\n\n        return callback(null, result);\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/utils.js":"'use strict';\n\n// Load modules\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.mergeOptions = function (parent, child, ignore) {\n\n    ignore = ignore || [];\n    const options = {};\n\n    Object.keys(parent || {}).forEach((key) => {\n\n        if (ignore.indexOf(key) === -1) {\n            options[key] = parent[key];\n        }\n    });\n\n    Object.keys(child || {}).forEach((key) => {\n\n        options[key] = child[key];\n    });\n\n    return options;\n};\n\n\nexports.applyOptions = function (parent, child) {\n\n    Object.keys(child).forEach((key) => {\n\n        parent[key] = child[key];\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-lab/node_modules/lab/lib/cli.js":"'use strict';\n\n// Load modules\n\nconst Fs = require('fs');\nconst Path = require('path');\nconst Bossy = require('bossy');\nconst FindRc = require('find-rc');\nconst Hoek = require('hoek');\nconst Coverage = require('./coverage');\nconst Pkg = require('../package.json');\nconst Runner = require('./runner');\nconst Transform = require('./transform');\nconst Utils = require('./utils');\n// .labrc configuration will be required if it exists\n\n\n// Declare internals\n\nconst internals = {};\n\ninternals.rcPath = FindRc('lab');\ninternals.rc = internals.rcPath ? require(internals.rcPath) : {};\n\n\nexports.run = function () {\n\n    const settings = internals.options();\n\n    settings.coveragePath = Path.join(process.cwd(), settings['coverage-path'] || '');\n    settings.coverageExclude = ['node_modules', 'test', 'test_runner'];\n    if (settings['coverage-exclude']) {\n        settings.coverageExclude = settings.coverageExclude.concat(settings['coverage-exclude']);\n    }\n\n    settings.lintingPath = process.cwd();\n\n    if (settings.coverage) {\n        Coverage.instrument(settings);\n    }\n    else if (settings.transform) {\n        Transform.install(settings);\n    }\n\n    if (settings.environment) {\n        process.env.NODE_ENV = settings.environment;\n    }\n\n    if (settings.sourcemaps) {\n        let sourceMapOptions = {};\n\n        if (settings.transform) {\n            sourceMapOptions = {\n                retrieveFile: Transform.retrieveFile\n            };\n        }\n\n        require('source-map-support').install(sourceMapOptions);\n    }\n\n    const scripts = internals.traverse(settings.paths, settings);\n    return Runner.report(scripts, settings);\n};\n\n\ninternals.traverse = function (paths, options) {\n\n    const traverse = function (path) {\n\n        let files = [];\n\n        const pathStat = Fs.statSync(path);\n        if (pathStat.isFile()) {\n            return path;\n        }\n\n        Fs.readdirSync(path).forEach((filename) => {\n\n            const file = Path.join(path, filename);\n            const stat = Fs.statSync(file);\n            if (stat.isDirectory() &&\n                !options.flat) {\n\n                files = files.concat(traverse(file, options));\n                return;\n            }\n\n            if (stat.isFile() &&\n                options.pattern.test(filename) &&\n                Path.basename(file)[0] !== '.') {\n\n                files.push(file);\n            }\n        });\n\n        return files;\n    };\n\n    let testFiles = [];\n    paths.forEach((path) => {\n\n        testFiles = testFiles.concat(traverse(path));\n    });\n\n    if (options.pattern && !testFiles.length) {\n        options.output.write('The pattern provided (-P or --pattern) didn\\'t match any files.');\n        process.exit(0);\n    }\n\n    testFiles = testFiles.map((path) => {\n\n        return Path.resolve(path);\n    });\n\n    const scripts = [];\n    testFiles.forEach((file) => {\n\n        global._labScriptRun = false;\n        file = Path.resolve(file);\n        const pkg = require(file);\n        if (pkg.lab &&\n            pkg.lab._root) {\n\n            scripts.push(pkg.lab);\n\n            if (pkg.lab._cli) {\n                Utils.applyOptions(options, pkg.lab._cli);\n            }\n        }\n        else if (global._labScriptRun) {\n            options.output.write('The file: ' + file + ' includes a lab script that is not exported via exports.lab');\n            return process.exit(1);\n        }\n    });\n\n    return scripts;\n};\n\n\ninternals.options = function () {\n\n    const definition = {\n        assert: {\n            alias: 'a',\n            type: 'string',\n            description: 'specify an assertion library module path to require and make available under Lab.assertions',\n            default: null\n        },\n        bail: {\n            type: 'boolean',\n            description: 'exit the process with a non zero exit code on the first test failure',\n            default: null\n        },\n        colors: {\n            alias: 'C',\n            type: 'boolean',\n            description: 'enable color output (defaults to terminal capabilities)',\n            default: null\n        },\n        'context-timeout': {\n            alias: 'M',\n            type: 'number',\n            description: 'timeout for before, after, beforeEach, afterEach in milliseconds',\n            default: null\n        },\n        coverage: {\n            alias: 'c',\n            type: 'boolean',\n            description: 'enable code coverage analysis',\n            default: null\n        },\n        'coverage-path': {\n            type: 'string',\n            description: 'set code coverage path',\n            default: null\n        },\n        'coverage-exclude': {\n            type: 'string',\n            description: 'set code coverage excludes',\n            multiple: true,\n            default: null\n        },\n        debug: {\n            alias: 'D',\n            type: 'boolean',\n            description: 'print the stack during a domain error event',\n            default: null\n        },\n        dry: {\n            alias: 'd',\n            type: 'boolean',\n            description: 'skip all tests (dry run)',\n            default: null\n        },\n        environment: {\n            alias: 'e',\n            type: 'string',\n            description: 'value to set NODE_ENV before tests',\n            default: null\n        },\n        flat: {\n            alias: 'f',\n            type: 'boolean',\n            description: 'prevent recursive collection of tests within the provided path',\n            default: null\n        },\n        globals: {\n            alias: ['I', 'ignore'],\n            type: 'string',\n            description: 'ignore a list of globals for the leak detection (comma separated)',\n            default: null\n        },\n        grep: {\n            alias: 'g',\n            type: 'string',\n            description: 'only run tests matching the given pattern which is internally compiled to a RegExp',\n            default: null\n        },\n        help: {\n            alias: 'h',\n            type: 'boolean',\n            description: 'display usage options',\n            default: null\n        },\n        id: {\n            alias: 'i',\n            type: 'range',\n            description: 'test identifier',\n            default: null\n        },\n        inspect: {\n            type: 'boolean',\n            description: 'starts lab with the node.js native debugger',\n            default: null\n        },\n        leaks: {\n            alias: 'l',\n            type: 'boolean',\n            description: 'disable global variable leaks detection',\n            default: null\n        },\n        lint: {\n            alias: 'L',\n            type: 'boolean',\n            description: 'enable linting',\n            default: null\n        },\n        linter: {\n            alias: 'n',\n            type: 'string',\n            description: 'linter path to use',\n            default: null\n        },\n        'lint-fix': {\n            type: 'boolean',\n            description: 'apply any fixes from the linter.',\n            default: null\n        },\n        'lint-options': {\n            type: 'string',\n            description: 'specify options to pass to linting program. It must be a string that is JSON.parse(able).',\n            default: null\n        },\n        'lint-errors-threshold': {\n            type: 'number',\n            description: 'linter errors threshold in absolute value',\n            default: null\n        },\n        'lint-warnings-threshold': {\n            type: 'number',\n            description: 'linter warnings threshold in absolute value',\n            default: null\n        },\n        output: {\n            alias: 'o',\n            type: 'string',\n            description: 'file path to write test results',\n            multiple: true,\n            default: null\n        },\n        parallel: {\n            alias: 'p',\n            type: 'boolean',\n            description: 'parallel test execution within each experiment',\n            default: null\n        },\n        pattern: {\n            alias: 'P',\n            type: 'string',\n            description: 'file pattern to use for locating tests',\n            default: null\n        },\n        rejections: {\n            alias: 'R',\n            type: 'boolean',\n            description: 'fail test on unhandled Promise rejections',\n            default: null\n        },\n        reporter: {\n            alias: 'r',\n            type: 'string',\n            description: 'reporter type [console, html, json, tap, lcov, clover, junit]',\n            multiple: true,\n            default: null\n        },\n        seed: {\n            type: 'string',\n            description: 'use this seed to randomize the order with `--shuffle`. This is useful to debug order dependent test failures',\n            default: null\n        },\n        shuffle: {\n            type: 'boolean',\n            description: 'shuffle script execution order',\n            default: null\n        },\n        silence: {\n            alias: 's',\n            type: 'boolean',\n            description: 'silence test output',\n            default: null\n        },\n        'silent-skips': {\n            alias: 'k',\n            type: 'boolean',\n            description: 'don’t output skipped tests',\n            default: null\n        },\n        sourcemaps: {\n            alias: ['S', 'sourcemaps'],\n            type: 'boolean',\n            description: 'enable support for sourcemaps',\n            default: null\n        },\n        threshold: {\n            alias: 't',\n            type: 'number',\n            description: 'code coverage threshold percentage',\n            default: null\n        },\n        timeout: {\n            alias: 'm',\n            type: 'number',\n            description: 'timeout for each test in milliseconds',\n            default: null\n        },\n        transform: {\n            alias: ['T', 'transform'],\n            type: 'string',\n            description: 'javascript file that exports an array of objects ie. [ { ext: \".js\", transform: function (content, filename) { ... } } ]',\n            default: null\n        },\n        verbose: {\n            alias: 'v',\n            type: 'boolean',\n            description: 'verbose test output',\n            default: null\n        },\n        version: {\n            alias: 'V',\n            type: 'boolean',\n            description: 'version information',\n            default: null\n        }\n    };\n\n    const defaults = {\n        bail: false,\n        coverage: false,\n        debug: false,\n        dry: false,\n        environment: 'test',\n        flat: false,\n        leaks: true,\n        lint: false,\n        linter: 'eslint',\n        'lint-fix': false,\n        'lint-errors-threshold': 0,\n        'lint-warnings-threshold': 0,\n        parallel: false,\n        paths: ['test'],\n        rejections: false,\n        reporter: 'console',\n        shuffle: false,\n        silence: false,\n        'silent-skips': false,\n        sourcemaps: false,\n        timeout: 2000,\n        verbose: false\n    };\n\n    const argv = Bossy.parse(definition);\n\n    if (argv instanceof Error) {\n        console.error(Bossy.usage(definition, 'lab [options] [path]'));\n        console.error('\\n' + argv.message);\n        process.exit(1);\n    }\n\n    if (argv.help) {\n        console.log(Bossy.usage(definition, 'lab [options] [path]'));\n        process.exit(0);\n    }\n\n    if (argv.version) {\n        console.log(Pkg.version);\n        process.exit(0);\n    }\n\n    const options = Utils.mergeOptions(defaults, internals.rc);\n    options.paths = argv._ ? [].concat(argv._) : options.paths;\n\n    const keys = ['assert', 'bail', 'colors', 'context-timeout', 'coverage', 'coverage-exclude',\n        'coverage-path', 'debug', 'dry', 'environment', 'flat', 'globals', 'grep',\n        'lint', 'lint-errors-threshold', 'lint-fix', 'lint-options', 'lint-warnings-threshold',\n        'linter', 'output', 'parallel', 'pattern', 'rejections', 'reporter', 'seed', 'shuffle', 'silence',\n        'silent-skips', 'sourcemaps', 'threshold', 'timeout', 'transform', 'verbose'];\n    for (let i = 0; i < keys.length; ++i) {\n        if (argv.hasOwnProperty(keys[i]) && argv[keys[i]] !== undefined && argv[keys[i]] !== null) {\n            options[keys[i]] = argv[keys[i]];\n        }\n    }\n\n    if (typeof argv.leaks === 'boolean') {\n        options.leaks = !argv.leaks;\n    }\n\n    if (argv.id) {\n        options.ids = argv.id;\n    }\n\n    if (Array.isArray(options.reporter) && options.output) {\n        if (!Array.isArray(options.output) || options.output.length !== options.reporter.length) {\n            console.error(Bossy.usage(definition, 'lab [options] [path]'));\n            process.exit(1);\n        }\n    }\n\n    if (!options.output) {\n        options.output = process.stdout;\n    }\n\n    if (options.assert) {\n        options.assert = require(options.assert);\n        require('./').assertions = options.assert;\n    }\n\n    if (options.globals) {\n        options.globals = options.globals.trim().split(',');\n    }\n\n    if (options.silence) {\n        options.progress = 0;\n    }\n    else if (options.verbose) {\n        options.progress = 2;\n    }\n\n    options.pattern = options.pattern ? '.*' + options.pattern + '.*?' : '';\n    if (options.transform) {\n        const transform = require(Path.resolve(options.transform));\n\n        Hoek.assert(Array.isArray(transform) && transform.length > 0, 'transform module must export an array of objects {ext: \".js\", transform: null or function (content, filename)}');\n        options.transform = transform;\n\n        const includes = 'js|' + transform.map(internals.mapTransform).join('|');\n        const regex = options.pattern + '\\\\.(' + includes + ')$';\n        options.pattern = new RegExp(regex);\n    }\n    else {\n        options.pattern = new RegExp(options.pattern + '\\\\.(js)$');\n    }\n\n    options.coverage = (options.coverage || options.threshold > 0 || options.reporter.indexOf('html') !== -1 || options.reporter.indexOf('lcov') !== -1 || options.reporter.indexOf('clover') !== -1);\n\n    return options;\n};\n\ninternals.mapTransform = function (transform) {\n\n    return transform.ext.substr(1).replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n};\n"}